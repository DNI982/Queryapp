/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a role-based access control model with user-level ownership for data sources.
 * User profiles are public, but only super-admins can manage pending user approvals and role-based permissions.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible to everyone for read operations.
 * - /pendingUsers/{userId}: Stores pending user registration requests, managed by super-admins.
 * - /dataSources/{dataSourceId}: Stores data source connection details, owned by individual users.
 * - /permissions/{permissionId}: Stores dynamic permissions for roles, managed by super-admins.
 *
 * Key Security Decisions:
 * - User profiles are publicly readable to facilitate user discovery and interaction.
 * - Listing of pending users is disallowed to prevent unauthorized access to registration information.
 * - Data sources are owned by individual users, preventing unauthorized access to connection details.
 *
 * Denormalization for Authorization:
 * The `dataSource` entity includes an `ownerId` field to simplify ownership checks,
 * avoiding the need for additional `get()` operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows read access to user profiles for everyone, and owner-only write access.
     * @path /users/{userId}
     * @allow (get, list) - Any user can read a user profile.
     * @allow (create, update, delete) - Only the user with matching {userId} can modify their own profile.
     * @deny (create, update, delete) - Another user attempts to modify a profile they don't own.
     * @principle Public read, owner-only writes, and self-creation for user profiles.
     */
    match /users/{userId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId && request.resource.data.email == resource.data.email && request.resource.data.role == resource.data.role;
      allow delete: if false;
    }

    /**
     * @description Allows super-admins to manage pending user approvals.
     * @path /pendingUsers/{userId}
     * @allow (create, update, get, delete) - A super-admin can manage pending user requests.
     * @deny (create, update, get, delete) - A non-super-admin attempts to manage pending user requests.
     * @deny (list) - No listing of pending users.
     * @principle Role-based access control for managing pending user registrations.
     */
    match /pendingUsers/{userId} {
      allow get: if hasRole(['super-admin']);
      allow list: if false;
      allow create: if hasRole(['super-admin']) && request.auth.uid == request.resource.data.uid;
      allow update: if hasRole(['super-admin']);
      allow delete: if hasRole(['super-admin']);
    }

    /**
     * @description Allows users to manage their own data source connections.
     * @path /dataSources/{dataSourceId}
     * @allow (create, get, list, update, delete) - The owner of the data source can manage it.
     * @deny (create, get, list, update, delete) - A non-owner attempts to manage a data source.
     * @principle Owner-only access control for data sources.
     */
    match /dataSources/{dataSourceId} {
      allow get: if isOwner(resource.data.ownerId);
      allow list: if isOwner(resource.data.ownerId);
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId) && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows super-admins to manage role-based permissions.
     * @path /permissions/{permissionId}
     * @allow (create, update, get, delete) - A super-admin can manage role permissions.
     * @deny (create, update, get, delete) - A non-super-admin attempts to manage role permissions.
     * @principle Role-based access control for managing dynamic permissions.
     */
    match /permissions/{permissionId} {
      allow get: if hasRole(['super-admin']);
      allow list: if hasRole(['super-admin']);
      allow create: if hasRole(['super-admin']);
      allow update: if hasRole(['super-admin']);
      allow delete: if hasRole(['super-admin']);
    }

    // --- Helper functions ---

    /**
     * @description Checks if the current user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user has the specified role.
     * @param {array} roles An array of roles to check against the user's claim.
     * @return {boolean} True if the user has at least one of the specified roles, false otherwise.
     */
    function hasRole(roles) {
      return isSignedIn() && roles.hasAny(request.auth.token.role);
    }

    /**
     * @description Checks if the current user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the resource and it exists.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}